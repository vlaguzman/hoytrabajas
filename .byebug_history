continue
subject.search_by( city: bogota.id, status: 'active', keywords: 'developer', job_categories: tech_category.id, work_mode: remote_mode.id, contract_type: indefinite_contract.id, available_work_days: monday.id ).count
subject.search_by( city: bogota.id, status: 'active', keywords: 'developer', job_categories: tech_category.id, work_mode: remote_mode.id, contract_type: indefinite_contract.id, available_work_days: monday.id )
friday
monday
subject.search_by( city: bogota.id, status: 'active', keywords: 'developer', job_categories: tech_category.id, work_mode: remote_mode.id, contract_type: indefinite_contract.id, available_work_days: monday.id )
subject.search_by( city: bogota.id, status: 'active', keywords: 'developer', job_categories: tech_category.id, work_mode: remote_mode.id, contract_type: indefinite_contract.id, available_work_days: monday.id ).count
subject.search_by( city: bogota.id, status: 'active', keywords: 'developer', job_categories: tech_category.id, work_mode: remote_mode.id, contract_type: indefinite_contract.id, available_work_days: monday.id, working_days: monday.id ).count
subject.search_by( city: bogota.id, status: 'active', keywords: 'developer', job_categories: tech_category.id, work_mode: remote_mode.id, contract_type: indefinite_contract.id, available_work_days: monday.id ).count
subject.search_by( city: bogota.id, status: 'active', keywords: 'developer', job_categories: tech_category.id, work_mode: remote_mode.id, contract_type: indefinite_contract.id ).count
subject.search_by( city: bogota.id, status: 'active', keywords: 'developer', job_categories: tech_category.id, work_mode: remote_mode.id ).count
subject.search_by( city: bogota.id, status: 'active', keywords: 'developer', job_categories: tech_category.id ).count
subject.search_by( city: bogota.id, status: 'active', keywords: 'developer' ).count
subject.search_by( city: bogota.id, status: 'active' ).count
subject.search_by( city: bogota.id ).count
subject.search_by(status: 'active' ).count
subject.search_by( keywords: 'developer').count
subject.search_by( keywords: 'developer')
search_parameters
subject.search_by( **search_parameters )
continue
pp subject.search_by.pluck(:title)
subject.search_by.pluck(:title)
subject.search_by.count
subject.search_by
response
continue
parameters_keys.select { |key| self.class::MULTIMATCH_PARAM_KEYS.include? key }
parameters_keys.include?(*self.class::MULTIMATCH_PARAM_KEYS)
parameters_keys.include? [:keywords]
parameters_keys.include? self.class::MULTIMATCH_PARAM_KEYS
parameters_keys - [:keywords]
parameters_keys - [:x]
[:x] - parameters_keys
[:keywords] - parameters_keys
self.class::MULTIMATCH_PARAM_KEYS - parameters_keys
self.class::MULTIMATCH_PARAM_KEYS - self.class::MULTIMATCH_PARAM_KEYS
self.class::MULTIMATCH_PARAM_KEYS
parameters_keys
keys_not_present
continue
pp query
continue
pp query
continue
pp query
optiones
continue
pp x
continue
ontinue
pp query
""
pp multimatch_merger(query: query, query_string: request_parameters[multimatch_clause])
""
multimatch_merger(query: query, query_string: request_parameters[multimatch_clause])
continue
a = query.tap do |field| field[:bool][:must].merge(multi_match: multi_match_builder(query_string: request_parameters[multimatch_clause])) end
a = query.tap do |field| field[:bool][:must].merge(multi_match: multi_match_builder(query_string: request_parameters[multimatch_clause])) 
pp query
""
query
continue
query.tap do |field|
pp query
continue
pp response.last
""
response
continue
x
continue
keys_not_present
x
continue
self.class::MULTIMATCH_PARAM_KEYS - []
self.class::MULTIMATCH_PARAM_KEYS - parameters_keys
parameters_keys
self.class::MULTIMATCH_PARAM_KEYS
x
continue
self.class
self.class::MULTIMATCH_PARAM_KEYS
x
continue
x
continue
x
exit
x
exit
Offer.search("*")
Offer.search("*").count
pp query.keys
pp query
""
query
request_parameters
query_type
model
exit
response.pluck(:created_at)
response
continue
response.last
response.count
continue
sort_field_builder(**parameter)
exit
sort_field_builder(parameter[:key], mode: parameter[:mode], order: parameter[:order])
sort_field_builder(parameter)
      parameter.is_a? Hash ? sort_field_builder(parameter[:key], mode: parameter[:mode], order: parameter[:order]) : sort_field_builder(parameter)
continue
parameter.is_a? Hash
parameter
continue
sort_parameters.map do |p| p.is_a? Symbol end
sort_parameters.map do |p| 
sort_parameters.map { |parameter| parameter.is_a? Symbol  }
sort_parameters.first.class
sort_parameters.last.is_a? Symbol
sort_parameters
exit
continue
query_type
exit
reload!
query
continue
iteration.count
iteration
continue
iteration.count
exit
continue
scroll_result.keys
scroll_body
results["hits"]["hits"].count
results["hits"]["total"]
results["total"].keys
results["hits"].keys
results
results["hits"]
results.keys
exit
a.keys
a = Elasticsearch::SearchService.scroll_request(client: Offer.__elasticsearch__.client, model_index: :offers, query: Elasticsearch::Offers::Queries.new.(request_parameters: {city: 1}).merge(size: 1000000) )
a.count
a.class
a = Elasticsearch::SearchService.scroll_request(client: Offer.__elasticsearch__.client, model_index: :offers, query: Elasticsearch::Offers::Queries.new.(request_parameters: {city: 1}).merge(size: 100000) )
a.count
a.class
a
a.keys
a = Elasticsearch::SearchService.scroll_request(client: Offer.__elasticsearch__.client, model_index: :offers, query: Elasticsearch::Offers::Queries.new.(request_parameters: {city: 1}).merge(size: 10000) )
a = Elasticsearch::SearchService.scroll_request(client: Offer.__elasticsearch__.client, model_index: :offers, query: Elasticsearch::Offers::Queries.new.(request_parameters: {city: 1}).merge(size: 10000, search_after: 0) )
results["_scroll_id"]
results.keys
results["hits"].keys
results["hits"]["hits"].count
results["hits"]["total"]
results["hits"].keys
results["hits"]
results["took"]
results.keys
results
exit
iteration.count
continue
iteration.count
continue
iteration.count
continue
iteration.count
exit
continue
exit
reload!
iteration.count
continue
iteration.count
continue
exit
scroll_id
iteration.last
iteration.count
iteration
exit
response.results[0].to_h.eql?(expected_object)
response.results[0].to_h
expected_object
response.results.count
response
exit
pp subject.__elasticsearch__.client.info
subject.__elasticsearch__.client.info
exit
request_parameters
exit
x
exit
query_type
request_parameters
exit
query_type = request_parameters.any? ? query_type : QUERY_TYPES[0]
query_type
query_type,
exit
query_type
exit
query_type
continue
response.results.count
exit
response.results[0].to_h
response.results[1].to_h
response.results[1]
Offer.count
continue
response.results.count
response
exit
response.results[1]
response.results
response.count
response
exit
subject.__elasticsearch__.client.get_source
subject.__elasticsearch__.client.get_sourcce
subject.__elasticsearch__.client.methods
subject.__elasticsearch__.client.host
subject.__elasticsearch__.client
subject.__elasticsearch__.inspect
subject.__elasticsearch__.methods
subject.__elasticsearch__.host
exit
q
continue
exit
save_page 'paps.html'
continue
exit
pp response.results[0].to_h
exit
response.size
exit
subject.__elasticsearch__.client
subject.__elasticsearch__.client.port
subject.__elasticsearch_.client.port
a.total_count
a.count
pp a[0]
a[0]
a.length
a = subject.search("*:*")
exit
